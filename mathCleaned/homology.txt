DEF	  A category MATH is called preadditive if each morphism set MATH is endowed with the structure of an abelian group such that the compositions MATH are bilinear. A functor MATH of preadditive categories is called additive if and only if MATH is a homomorphism of abelian groups for all MATH.  
LEM	  Let MATH be a preadditive category. Let MATH be an object of MATH. The following are equivalent <CASES> CASE: MATH is an initial object, CASE: MATH is a final object, and CASE: MATH in MATH. </CASES> Furthermore, if such an object MATH exists, then a morphism MATH factors through MATH if and only if MATH.  
DEF	  In a preadditive category MATH we call zero object, and we denote it MATH any final and initial object as in Lemma REF above.  
LEM	  Let MATH be a preadditive category. Let MATH. If the product MATH exists, then so does the coproduct MATH. If the coproduct MATH exists, then so does the product MATH. In this case also MATH.  
DEF	  Given a pair of objects MATH in a preadditive category MATH, the direct sum MATH of MATH and MATH is the direct product MATH endowed with the morphisms MATH as in Lemma REF above.  
LEM	  Let MATH, MATH be preadditive categories. Let MATH be an additive functor. Then MATH transforms direct sums to direct sums and zero to zero.  
DEF	  A category MATH is called additive if it is preadditive and finite products exist, in other words it has a zero object and direct sums.  
DEF	  Let MATH be a preadditive category. Let MATH be a morphism. <CASES> CASE: A kernel of MATH is a morphism MATH such that (a) MATH and (b) for any MATH such that MATH there exists a unique morphism MATH such that MATH. CASE: If the kernel of MATH exists, then we denote this MATH. CASE: A cokernel of MATH is a morphism MATH such that (a) MATH and (b) for any MATH such that MATH there exists a unique morphism MATH such that MATH. CASE: If a cokernel of MATH exists we denote this MATH. CASE: If a kernel of MATH exists, then a coimage of MATH is a cokernel for the morphism MATH. CASE: If a kernel and coimage exist then we denote this MATH. CASE: If a cokernel of MATH exists, then the image of MATH is a kernel of the morphism MATH. CASE: If a cokernel and image of MATH exist then we denote this MATH. </CASES>  
LEM	  Let MATH be a preadditive category. Let MATH with morphisms MATH as in Lemma REF be a direct sum in MATH. Then MATH is a kernel of MATH. Dually, MATH is a cokernel for MATH.  
LEM	  Let MATH be a preadditive category. Let MATH be a morphism in MATH. <CASES> CASE: If a kernel of MATH exists, then this kernel is a monomorphism. CASE: If a cokernel of MATH exists, then this cokernel is an epimorphism. CASE: If a kernel and coimage of MATH exist, then the coimage is an epimorphism. CASE: If a cokernel and image of MATH exist, then the image is a monomorphism. </CASES>  
LEM	  Let MATH be a morphism in a preadditive category such that the kernel, cokernel, image and coimage all exist. Then MATH can be factored uniquely as MATH.  
DEF	  Let MATH be a preadditive category. We say MATH is Karoubian if every idempotent endomorphism of an object of MATH has a kernel.  
LEM	  Let MATH be a preadditive category. The following are equivalent <CASES> CASE: MATH is Karoubian, CASE: every idempotent endomorphism of an object of MATH has a cokernel, and CASE: given an idempotent endomorphism MATH of MATH there exists a direct sum decomposition MATH such that MATH corresponds to the projection onto MATH. </CASES>  
LEM	  Let MATH be a preadditive category. <CASES> CASE: If MATH has countable products and kernels of maps which have a right inverse, then MATH is Karoubian. CASE: If MATH has countable coproducts and cokernels of maps which have a left inverse, then MATH is Karoubian. </CASES>  
DEF	  A category MATH is abelian if it is additive, if all kernels and cokernels exist, and if the natural map MATH is an isomorphism for all morphisms MATH of MATH.  
LEM	  Let MATH be a preadditive category. The additions on sets of morphisms make MATH into a preadditive category. Furthermore, MATH is additive if and only if MATH is additive, and MATH is abelian if and only if MATH is abelian.  
DEF	  Let MATH be a morphism in an abelian category. <CASES> CASE: We say MATH is injective if MATH. CASE: We say MATH is surjective if MATH. </CASES> If MATH is injective, then we say that MATH is a subobject of MATH and we use the notation MATH. If MATH is surjective, then we say that MATH is a quotient of MATH.  
LEM	  Let MATH be a morphism in an abelian category MATH. Then <CASES> CASE: MATH is injective if and only if MATH is a monomorphism, CASE: MATH is surjective if and only if MATH is an epimorphism, and CASE: MATH is an isomorphism if and only if MATH is injective and surjective. </CASES>  
LEM	  Let MATH be an abelian category. All finite limits and finite colimits exist in MATH.  
DEF	  Let MATH be an additive category. Consider a sequence of morphisms MATH in MATH. We say such a sequence is a complex if the composition of any two consecutive (drawn) arrows is zero. If MATH is abelian then we say a complex of the first type above is exact at MATH if MATH and we say a complex of the second kind is exact at MATH where MATH if MATH. We a sequence as above is exact or is an exact sequence or is an exact complex if it is a complex and exact at every object (in the first case) or exact at MATH for all MATH (in the second case). There are variants of these notions for sequences of the form MATH A short exact sequence is an exact complex of the form MATH  
LEM	  Let MATH be an abelian category. Let MATH be a complex of MATH. <CASES> CASE: MATH is exact if and only if MATH is an exact sequence of abelian groups for all objects MATH of MATH, and CASE: MATH is exact if and only if MATH is an exact sequence of abelian groups for all objects MATH of MATH. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH and MATH be morphisms of MATH such that MATH is a short exact sequence. We say the short exact sequence is split if there exist morphisms MATH and MATH such that MATH is the direct sum of MATH and MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a short exact sequence. <CASES> CASE: Given a morphism MATH right inverse to MATH, there exists a unique MATH such that MATH splits the short exact sequence as in Definition REF. CASE: Given a morphism MATH left inverse to MATH, there exists a unique MATH such that MATH splits the short exact sequence as in Definition REF. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a commutative diagram.  <CASES> CASE: The diagram is cartesian if and only if  MATH is exact. CASE: The diagram is cocartesian if and only if  MATH is exact. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a commutative diagram. <CASES> CASE: If the diagram is cartesian, then the morphism  MATH induced by MATH is an isomorphism. CASE: If the diagram is cocartesian, then the morphism  MATH induced by MATH is an isomorphism. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a commutative diagram. <CASES> CASE: If the diagram is cartesian and MATH is an epimorphism,  then the diagram is cocartesian and MATH is an epimorphism. CASE: If the diagram is cocartesian and MATH is a monomorphism,  then the diagram is cartesian and MATH is a monomorphism. </CASES>  
LEM	  Let MATH be an abelian category. <CASES> CASE: If MATH is surjective, then for every MATH the projection MATH is surjective. CASE: If MATH is injective, then for every MATH the morphism MATH is injective. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH and MATH  be morphisms with MATH. Then, the following statements are equivalent: <CASES> CASE: The sequence MATH is exact. CASE: For every MATH with MATH there exist an object MATH,  an epimorphism MATH and a morphism MATH with MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a commutative diagram. <CASES> CASE: If the first row is exact and MATH is a monomorphism, then the induced  sequence MATH  is exact. CASE: If the second row is exact and MATH is an epimorphism, then the induced  sequence MATH  is exact. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a commutative diagram with exact rows. <CASES> CASE: There exists a unique morphism MATH such that the diagram MATH commutes, where MATH and MATH are the canonical projections and MATH and MATH are the canonical coprojections. CASE: The induced sequence MATH is exact. If MATH is injective then so is MATH, and if MATH is surjective then so is MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let  MATH be a commutative diagram with exact rows. Then, the induced diagram MATH commutes.  
LEM	  Let MATH be an abelian category. Let MATH be a commutative diagram with exact rows. <CASES> CASE: If MATH are surjective and MATH is injective, then MATH is surjective. CASE: If MATH are injective and MATH is surjective, then MATH is injective. </CASES>  
LEM	  REF Let MATH be an abelian category. Let MATH be a commutative diagram with exact rows. If MATH are isomorphisms, MATH is injective, and MATH is surjective then MATH is an isomorphism.  
DEF	  Let MATH be an abelian category. Let MATH. An extension MATH of MATH by MATH is a short exact sequence MATH A morphism of extensions between two extensions MATH and MATH means a morphism MATH in MATH making the diagram MATH commutative. Thus, the extensions of MATH by MATH form a category.  
DEF	  Let MATH be an abelian category. Let MATH. The set of isomorphism classes of extensions of MATH by MATH is denoted MATH This is called the MATH-group.  
LEM	  The construction MATH above defines a commutative group law on MATH which is functorial in both variables.  
LEM	  Let MATH be an abelian category. Let MATH be a short exact sequence in MATH. <CASES> CASE: There is a canonical six term exact sequence of abelian groups MATH for all objects MATH of MATH, and CASE: there is a canonical six term exact sequence of abelian groups MATH for all objects MATH of MATH. </CASES>  
LEM	  Let MATH and MATH be additive categories. Let MATH be a functor. The following are equivalent <CASES> CASE: MATH is additive, CASE: MATH is an isomorphism for all MATH, and CASE: MATH  is an isomorphism for all MATH. </CASES>  
LEM	  Let MATH and MATH be abelian categories. Let MATH be a functor. <CASES> CASE: If MATH is either left or right exact, then it is additive. CASE: MATH is left exact if and only if for every short exact sequence MATH the sequence MATH is exact. CASE: MATH is right exact if and only if for every short exact sequence MATH the sequence MATH is exact. CASE: MATH is exact if and only if for every short exact sequence MATH the sequence MATH is exact. </CASES>  
LEM	  Let MATH and MATH be abelian categories. Let MATH be an exact functor. For every pair of objects MATH of MATH the functor MATH induces an abelian group homomorphism MATH which maps the extension MATH to MATH.  
LEM	  Let MATH and MATH be functors. Assume that <CASES> CASE: MATH, MATH are additive categories, MATH, MATH are additive functors, and MATH is right adjoint to MATH, CASE: MATH is abelian and MATH is left exact, and CASE: MATH. </CASES> Then MATH is abelian.  
LEM	  Let MATH be a preadditive category. Let MATH be a left or right multiplicative system. There exists a unique preadditive structure on MATH such that the localization functor MATH is additive.  
LEM	  Let MATH be an additive category. Let MATH be a left or right multiplicative system. Then MATH is an additive category and the localization functor MATH is additive.  
LEM	  Let MATH be an additive category. Let MATH be a multiplicative system. Let MATH be an object of MATH. The following are equivalent <CASES> CASE: MATH in MATH, CASE: there exists MATH such that MATH is an element of MATH, and CASE: there exists MATH such that MATH is an element of MATH. </CASES>  
LEM	  Let MATH be an abelian category. <CASES> CASE: If MATH is a left multiplicative system, then the category MATH has cokernels and the functor MATH commutes with them. CASE: If MATH is a right multiplicative system, then the category MATH has kernels and the functor MATH commutes with them. CASE: If MATH is a multiplicative system, then the category MATH is abelian and the functor MATH is exact. </CASES>  
DEF	  Let MATH be an abelian category. An object MATH of MATH is said to be simple if it is nonzero and the only subobjects of MATH are MATH and MATH.  
DEF	  Let MATH be an abelian category. <CASES> CASE: We say an object MATH of MATH is Artinian if and only if it satisfies the descending chain condition for subobjects. CASE: We say MATH is Artinian if every object of MATH is Artinian. </CASES>  
DEF	  Let MATH be an abelian category. <CASES> CASE: We say an object MATH of MATH is Noetherian if and only if it satisfies the ascending chain condition for subobjects. CASE: We say MATH is Noetherian if every object of MATH is Noetherian. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a short exact sequence of MATH. Then MATH is Artinian if and only if MATH and MATH are Artinian.  
LEM	  Let MATH be an abelian category. Let MATH be a short exact sequence of MATH. Then MATH is Noetherian if and only if MATH and MATH are Noetherian.  
LEM	  Let MATH be an abelian category. Let MATH be an object of MATH. The following are equivalent <CASES> CASE: MATH is Artinian and Noetherian, and CASE: there exists a filtration MATH by subobjects such that MATH is simple for MATH. </CASES>  
LEM	[Jordan-Holder]  Let MATH be an abelian category. Let MATH be an object of MATH satisfying the equivalent conditions of Lemma REF. Given two filtrations MATH with MATH and MATH simple objects we have MATH and there exists a permutation MATH of MATH such that MATH for all MATH.  
DEF	  REF Let MATH be an abelian category. <CASES> CASE: A Serre subcategory of MATH is a nonempty full subcategory MATH of MATH such that given an exact sequence MATH with MATH, then also MATH. CASE: A weak Serre subcategory of MATH is a nonempty full subcategory MATH of MATH such that given an exact sequence MATH with MATH in MATH, then also MATH in MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a subcategory of MATH. Then MATH is a Serre subcategory if and only if the following conditions are satisfied: <CASES> CASE: MATH, CASE: MATH is a strictly full subcategory of MATH, CASE: any subobject or quotient of an object of MATH is an object of MATH, CASE: if MATH is an extension of objects of MATH then also MATH. </CASES> Moreover, a Serre subcategory is an abelian category and the inclusion functor is exact.  
LEM	  Let MATH be an abelian category. Let MATH be a subcategory of MATH. Then MATH is a weak Serre subcategory if and only if the following conditions are satisfied: <CASES> CASE: MATH, CASE: MATH is a strictly full subcategory of MATH, CASE: kernels and cokernels in MATH of morphisms between objects of MATH are in MATH, CASE: if MATH is an extension of objects of MATH then also MATH. </CASES> Moreover, a weak Serre subcategory is an abelian category and the inclusion functor is exact.  
LEM	  Let MATH, MATH be abelian categories. Let MATH be an exact functor. Then the full subcategory of objects MATH of MATH such that MATH forms a Serre subcategory of MATH.  
DEF	  Let MATH, MATH be abelian categories. Let MATH be an exact functor. Then the full subcategory of objects MATH of MATH such that MATH is called the kernel of the functor MATH, and is sometimes denoted MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a Serre subcategory. There exists an abelian category MATH and an exact functor MATH which is essentially surjective and whose kernel is MATH. The category MATH and the functor MATH are characterized by the following universal property: For any exact functor MATH such that MATH there exists a factorization MATH for a unique exact functor MATH.  
LEM	  Let MATH, MATH be abelian categories. Let MATH be an exact functor. Let MATH be a Serre subcategory contained in the kernel of MATH. Then MATH if and only if the induced functor MATH (Lemma REF) is faithful.  
DEF	  Let MATH be an abelian category. We denote MATH the zeroth MATH-group of MATH. It is the abelian group constructed as follows. Take the free abelian group on the objects on MATH and for every short exact sequence MATH impose the relation MATH.  
LEM	  Let MATH be an exact functor between abelian categories. Then MATH induces a homomorphism of MATH-groups MATH by simply setting MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a Serre subcategory and set MATH. <CASES> CASE: The exact functors MATH and MATH induce an exact sequence MATH of MATH-groups, and CASE: the kernel of MATH is equal to the collection of elements of the form MATH where MATH is a complex as in (REF) with the property that it becomes exact in MATH; in other words that MATH and MATH are objects of MATH. </CASES>  
DEF	  Let MATH be abelian categories. A cohomological MATH-functor or simply a MATH-functor from MATH to MATH is given by the following data: <CASES> CASE: a collection MATH, MATH of additive functors, and CASE: for every short exact sequence MATH of MATH a collection MATH, MATH of morphisms of MATH. </CASES> These data are assumed to satisfy the following axioms <CASES> CASE: for every short exact sequence as above the sequence MATH is exact, and CASE: for every morphism MATH of short exact sequences of MATH the diagrams MATH are commutative. </CASES>  
DEF	  Let MATH be abelian categories. Let MATH and MATH be MATH-functors from MATH to MATH. A morphism of MATH-functors from MATH to MATH is a collection of transformation of functors MATH, MATH such that for every short exact sequence MATH of MATH the diagrams MATH are commutative.  
DEF	  Let MATH be abelian categories. Let MATH be a MATH-functor from MATH to MATH. We say MATH is a universal MATH-functor if and only if for every MATH-functor MATH and any morphism of functors MATH there exists a unique morphism of MATH-functors MATH such that MATH.  
LEM	  Let MATH be abelian categories. Let MATH be a MATH-functor from MATH to MATH. Suppose that for every MATH and any MATH there exists an injective morphism MATH (depending on MATH and MATH) such that MATH is zero. Then MATH is a universal MATH-functor.  
LEM	  Let MATH be abelian categories. Let MATH be a functor. If there exists a universal MATH-functor MATH from MATH to MATH with MATH, then it is determined up to unique isomorphism of MATH-functors.  
LEM	  [ Hom functors of MATH respect the homotopy relation. ] Let MATH be an additive category. Let MATH be morphisms of chain complexes. Suppose given morphisms of chain complexes MATH, and MATH. If MATH defines a homotopy between MATH and MATH, then MATH defines a homotopy between MATH and MATH.  
DEF	  Let MATH be an additive category. We say a morphism MATH is a homotopy equivalence if there exists a morphism MATH such that there exists a homotopy between MATH and MATH and there exists a homotopy between MATH and MATH. If there exists such a morphism between MATH and MATH, then we say that MATH and MATH are homotopy equivalent.  
LEM	  Let MATH be an abelian category. <CASES> CASE: The category of chain complexes in MATH is abelian. CASE: A morphism of complexes MATH is injective if and only if each MATH is injective. CASE: A morphism of complexes MATH is surjective if and only if each MATH is surjective. CASE: A sequence of chain complexes MATH is exact at MATH if and only if each sequence MATH is exact at MATH. </CASES>  
DEF	  Let MATH be an abelian category. <CASES> CASE: A morphism of chain complexes MATH is called a quasi-isomorphism if the induced map MATH is an isomorphism for all MATH. CASE: A chain complex MATH is called acyclic if all of its homology objects MATH are zero. </CASES>  
LEM	  Let MATH be an abelian category. <CASES> CASE: If the maps MATH are homotopic, then the induced maps MATH and MATH are equal. CASE: If the map MATH is a homotopy equivalence, then MATH is a quasi-isomorphism. </CASES>  
LEM	  Let MATH be an abelian category. Suppose that MATH is a short exact sequence of chain complexes of MATH. Then there is a canonical long exact homology sequence MATH  
LEM	  Let MATH be an additive category. Let MATH be morphisms of cochain complexes. Suppose given morphisms of cochain complexes MATH, and MATH. If MATH defines a homotopy between MATH and MATH, then MATH defines a homotopy between MATH and MATH.  
DEF	  Let MATH be an additive category. We say a morphism MATH is a homotopy equivalence if there exists a morphism MATH such that there exists a homotopy between MATH and MATH and there exists a homotopy between MATH and MATH. If there exists such a morphism between MATH and MATH, then we say that MATH and MATH are homotopy equivalent.  
LEM	  Let MATH be an abelian category. <CASES> CASE: The category of cochain complexes in MATH is abelian. CASE: A morphism of cochain complexes MATH is injective if and only if each MATH is injective. CASE: A morphism of cochain complexes MATH is surjective if and only if each MATH is surjective. CASE: A sequence of cochain complexes MATH is exact at MATH if and only if each sequence MATH is exact at MATH. </CASES>  
DEF	  Let MATH be an abelian category. <CASES> CASE: A morphism of cochain complexes MATH of MATH is called a quasi-isomorphism if the induced maps MATH is an isomorphism for all MATH. CASE: A cochain complex MATH is called acyclic if all of its cohomology objects MATH are zero. </CASES>  
LEM	  Let MATH be an abelian category. <CASES> CASE: If the maps MATH are homotopic, then the induced maps MATH and MATH are equal. CASE: If MATH is a homotopy equivalence, then MATH is a quasi-isomorphism. </CASES>  
LEM	  [ Short exact sequences of complexes give rise to long exact sequences of (co)homology. ] Let MATH be an abelian category. Suppose that MATH is a short exact sequence of cochain complexes of MATH. Then there is a long exact cohomology sequence MATH The construction produces long exact cohomology sequences which are functorial in the short exact sequence and compatible with shifts as in Definition REF.  
DEF	  Let MATH be an additive category. Let MATH be a chain complex with boundary maps MATH. For any MATH we define the MATH-shifted chain complex MATH as follows: <CASES> CASE: we set MATH, and CASE: we set MATH equal to MATH. </CASES> If MATH is a morphism of chain complexes, then we let MATH be the morphism of chain complexes with MATH.  
DEF	  Let MATH be an abelian category. Let MATH be a chain complex with boundary maps MATH. For any MATH we identify MATH via the identification MATH.  
LEM	  Let MATH be an additive category. Suppose that MATH and MATH are chain complexes. Given any morphism of chain complexes MATH there is a bijection between the set of homotopies from MATH to MATH and MATH. More generally, the set of homotopies between MATH and MATH is either empty or a principal homogeneous space under the group MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a short exact sequence of complexes. Suppose that MATH is a family of morphisms which split the short exact sequences MATH. Let MATH be the associated projections, see Lemma REF. Then the family of morphisms MATH define a morphism of complexes MATH.  
LEM	  Notation and assumptions as in Lemma REF above. The morphism of complexes MATH induces the maps MATH which occur in the long exact homology sequence associated to the short exact sequence of chain complexes by Lemma REF.  
LEM	  Notation and assumptions as in Lemma REF above. Suppose MATH is a second choice of splittings. Write MATH for some unique morphisms MATH. The family of maps MATH is a homotopy between the associated morphisms MATH.  
DEF	  Let MATH be an additive category. Let MATH be a cochain complex with boundary maps MATH. For any MATH we define the MATH-shifted cochain complex MATH as follows: <CASES> CASE: we set MATH, and CASE: we set MATH equal to MATH. </CASES> If MATH is a morphism of cochain complexes, then we let MATH be the morphism of cochain complexes with MATH.  
DEF	  Let MATH be an abelian category. Let MATH be a cochain complex with boundary maps MATH. For any MATH we identify MATH via the identification MATH.  
LEM	  Let MATH be an additive category. Suppose that MATH and MATH are cochain complexes. Given any morphism of cochain complexes MATH there is a bijection between the set of homotopies from MATH to MATH and MATH. More generally, the set of homotopies between MATH and MATH is either empty or a principal homogeneous space under the group MATH.  
LEM	  Let MATH be an additive category. Let MATH be a complex (!) of complexes. Suppose that we are given splittings MATH compatible with the maps in the displayed sequence. Let MATH and MATH be the corresponding maps. Then the family of morphisms MATH define a morphism of complexes MATH.  
LEM	  Notation and assumptions as in Lemma REF above. Assume in addition that MATH is abelian. The morphism of complexes MATH induces the maps MATH which occur in the long exact homology sequence associated to the short exact sequence of cochain complexes by Lemma REF.  
LEM	  Notation and assumptions as in Lemma REF. Let MATH, MATH be the given morphisms of complexes. Suppose MATH and MATH is a second choice of splittings. Write MATH and MATH for some unique morphisms MATH and MATH. Then <CASES> CASE: MATH, and CASE: the family of maps MATH is a homotopy between MATH, more precisely MATH. </CASES>  
DEF	  Let MATH be an additive category. The category of graded objects of MATH, denoted MATH, is the category with <CASES> CASE: objects MATH are families of objects MATH, MATH of objects of MATH, and CASE: morphisms MATH are families of morphisms MATH of MATH. </CASES>  
LEM	  Let MATH be an abelian category. The category of graded objects MATH is abelian.  
DEF	  Let MATH be an additive category. If MATH is a graded object, then the MATHth shift MATH is the graded object with MATH.  
DEF	  An additive monoidal category is an additive category MATH endowed with a monoidal structure MATH (Categories, Definition REF) such that MATH is an additive functor in each variable.  
LEM	  Let MATH be an additive monoidal category. If MATH, MATH are left duals of MATH, MATH, then MATH is a left dual of MATH.  
LEM	  In a Karoubian additive monoidal category every summand of an object which has a left dual has a left dual.  
LEM	  Let MATH be a field. Let MATH be the category of graded MATH-vector spaces viewed as a monoidal category as in Example REF. If MATH in MATH has a left dual MATH, then MATH and the map MATH defines nondegenerate pairings MATH.  
DEF	  Let MATH be an additive category. A double complex in MATH is given by a system MATH, where each MATH is an object of MATH and MATH and MATH are morphisms of MATH such that the following rules hold: <CASES> CASE: MATH CASE: MATH CASE: MATH </CASES> for all MATH.  
DEF	  Let MATH be an additive category. Let MATH be a double complex. The associated simple complex, denoted MATH, also often called the associated total complex, denoted MATH, is given by MATH (if it exists) with differential MATH  
DEF	  Let MATH be an abelian category. <CASES> CASE: A decreasing filtration MATH on an object MATH is a family MATH of subobjects of MATH such that MATH CASE: A filtered object of MATH is pair MATH consisting of an object MATH of MATH and a decreasing filtration MATH on MATH. CASE: A morphism MATH of filtered objects is given by a morphism MATH of MATH such that MATH for all MATH. CASE: The category of filtered objects is denoted MATH. CASE: Given a filtered object MATH and a subobject MATH the induced filtration on MATH is the filtration with MATH. CASE: Given a filtered object MATH and a surjection MATH the quotient filtration is the filtration with MATH. CASE: A filtration MATH on an object MATH is said to be finite if there exist MATH such that MATH and MATH. CASE: Given a filtered object MATH we say MATH exists if there exists a biggest subobject of MATH contained in all MATH. We say MATH exists if there exists a smallest subobject of MATH containing all MATH. CASE: The filtration on a filtered object MATH is said to be separated if MATH and exhaustive if MATH. </CASES>  
LEM	  Let MATH be an abelian category. The category of filtered objects MATH has the following properties: <CASES> CASE: It is an additive category. CASE: It has a zero object. CASE: It has kernels and cokernels, images and coimages. CASE: In general it is not an abelian category. </CASES>  
DEF	  Let MATH be an abelian category. A morphism MATH of filtered objects of MATH is said to be strict if MATH for all MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a morphism of filtered objects of MATH. The following are equivalent <CASES> CASE: MATH is strict, CASE: the morphism MATH of Lemma REF is an isomorphism. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a strict monomorphism of filtered objects. Let MATH be a morphism of filtered objects. Then MATH is a strict monomorphism.  
LEM	  Let MATH be an abelian category. Let MATH be a strict epimorphism of filtered objects. Let MATH be a morphism of filtered objects. Then MATH is a strict epimorphism.  
LEM	  Let MATH be an abelian category. Let MATH, MATH be filtered objects. Let MATH be a morphism of filtered objects. If MATH is injective then MATH is strict if and only if the filtration on MATH is the induced filtration. If MATH is surjective then MATH is strict if and only if the filtration on MATH is the quotient filtration.  
LEM	  Let MATH be an abelian category. Let MATH, MATH be strict morphisms of filtered objects. <CASES> CASE: In general the composition MATH is not strict. CASE: If MATH is injective, then MATH is strict. CASE: If MATH is surjective, then MATH is strict. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a filtered object of MATH. Let MATH be subobjects of MATH. On the object MATH the quotient filtration coming from the induced filtration on MATH and the induced filtration coming from the quotient filtration on MATH agree. Any of the morphisms MATH, MATH, MATH, MATH, MATH, MATH are strict (with induced/quotient filtrations).  
LEM	  Let MATH be an abelian category. Let MATH. Let MATH and MATH be morphisms. Then there exists a pushout MATH in MATH. If MATH is strict, so is MATH.  
LEM	  Let MATH be an abelian category. Let MATH. Let MATH and MATH be morphisms. Then there exists a fibre product MATH in MATH. If MATH is strict, so is MATH.  
LEM	  Let MATH be an abelian category. <CASES> CASE: Let MATH be a filtered object and MATH. Then for each MATH the sequence MATH is exact (with induced filtration on MATH and quotient filtration on MATH). CASE: Let MATH be a morphism of filtered objects of MATH. Then for each MATH the sequences MATH and MATH are exact. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a morphism of finite filtered objects of MATH. The following are equivalent <CASES> CASE: MATH is strict, CASE: the morphism MATH is an isomorphism, CASE: MATH is an isomorphism, CASE: the sequence MATH is exact, CASE: the sequence MATH is exact, and CASE: the sequence MATH is exact. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a complex of filtered objects of MATH. Assume MATH and MATH are strict morphisms of filtered objects. Then MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a complex of filtered objects of MATH. Assume MATH have finite filtrations and that MATH is exact. Then <CASES> CASE: for each MATH the sequence MATH is exact, CASE: for each MATH the sequence MATH is exact, CASE: for each MATH the sequence MATH is exact, CASE: the maps MATH and MATH are strict, and CASE: MATH is exact (as a sequence in MATH). </CASES>  
DEF	  Let MATH be an abelian category. <CASES> CASE: A spectral sequence in MATH is given by a system MATH where each MATH is an object of MATH, each MATH is a morphism such that MATH and MATH for MATH. CASE: A morphism of spectral sequences MATH is given by a family of morphisms MATH such that MATH and such that MATH is the morphism induced by MATH via the identifications MATH and MATH. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH be a spectral sequence. <CASES> CASE: If the subobjects MATH and MATH of MATH exist then we define the limit of the spectral sequence to be the object MATH. CASE: We say that the spectral sequence degenerates at MATH if the differentials MATH are all zero. </CASES>  
DEF	  Let MATH be an abelian category. <CASES> CASE: An exact couple is a datum MATH where MATH, MATH are objects of MATH and MATH, MATH, MATH are morphisms as in the following diagram MATH with the property that the kernel of each arrow is the image of its predecessor. So MATH, MATH, and MATH. CASE: A morphism of exact couples MATH is given by morphisms MATH and MATH such that MATH, MATH, and MATH. </CASES>  
LEM	  Let MATH be an exact couple in an abelian category MATH. Set <CASES> CASE: MATH so that MATH, CASE: MATH, CASE: MATH, CASE: MATH induced by MATH, CASE: MATH induced by MATH, CASE: MATH induced by ``MATH''. </CASES> Then we have <CASES> CASE: MATH, CASE: MATH, CASE: MATH is an exact couple. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH be an exact couple. The spectral sequence associated to the exact couple is the spectral sequence MATH with MATH, MATH, MATH, MATH, MATH, MATH, and so on.  
LEM	  Let MATH be an abelian category. Let MATH be an exact couple. Let MATH be the spectral sequence associated to the exact couple. In this case we have MATH and the map MATH is described by the following rule: For any (test) object MATH of MATH and any elements MATH and MATH such that MATH we have MATH where MATH is the induced morphism.  
DEF	  Let MATH be an abelian category. A differential object of MATH is a pair MATH consisting of an object MATH of MATH endowed with a selfmap MATH such that MATH. A morphism of differential objects MATH is given by a morphism MATH such that MATH.  
LEM	  [ The category of differential objects of an abelian category is itself an abelian category. ] Let MATH be an abelian category. The category of differential objects of MATH is abelian.  
DEF	  For a differential object MATH we denote MATH its homology.  
LEM	  Let MATH be an abelian category. Let MATH be a short exact sequence of differential objects. Then we get an exact homology sequence MATH  
DEF	  Let MATH be an abelian category. Let MATH be a differential object of MATH. Let MATH be an injective selfmap of MATH which commutes with MATH. The spectral sequence associated to MATH is the spectral sequence MATH described above.  
DEF	  Let MATH be an abelian category. A filtered differential object MATH is a filtered object MATH of MATH endowed with an endomorphism MATH whose square is zero: MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a filtered differential object of MATH. There is a spectral sequence MATH in MATH associated to MATH such that MATH for all MATH and such that the graded pieces MATH and maps MATH are as given above. Furthermore, MATH, MATH, and MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a filtered differential object of MATH. The spectral sequence MATH associated to MATH has MATH equal to the boundary map in homology associated to the short exact sequence of differential objects MATH  
DEF	  Let MATH be an abelian category. Let MATH be a filtered differential object of MATH. The induced filtration on MATH is the filtration defined by MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a filtered differential object of MATH. If MATH and MATH exist (see proof), then <CASES> CASE: the limit MATH exists and is graded having MATH in degree MATH, and CASE: the associated graded MATH of the cohomology of MATH is a graded subquotient of the graded limit object MATH. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH be a filtered differential object of MATH. We say the spectral sequence associated to MATH <CASES> CASE: weakly converges to MATH if MATH via Lemma REF, CASE: abuts to MATH if it weakly converges to MATH and we have MATH and MATH, </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a filtered differential object of MATH. The associated spectral sequence <CASES> CASE: weakly converges to MATH if and only if for every MATH we have equality in equations (REF) and (REF), CASE: abuts to MATH if and only if it weakly converges to MATH and MATH and MATH. </CASES>  
DEF	  Let MATH be an abelian category. A filtered complex MATH of MATH is a complex of MATH (see Definition REF).  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. There is a spectral sequence MATH in the category of bigraded objects of MATH associated to MATH such that MATH has bidegree MATH and such that MATH has bigraded pieces MATH and maps MATH as given above. Furthermore, we have MATH, MATH, and MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. Assume MATH has countable direct sums. Let MATH be the spectral sequence associated to MATH. <CASES> CASE: The map MATH is equal to the boundary map in cohomology associated to the short exact sequence of complexes MATH CASE: Assume that MATH for all MATH. Then MATH induces the zero differential on MATH and hence MATH. Furthermore, in this case MATH is the morphism induced by MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a morphism of filtered complexes of MATH. Let MATH, resp.\ MATH be the spectral sequence associated to MATH, resp.\ MATH. The morphism MATH induces a canonical morphism of spectral sequences MATH compatible with the bigradings.  
DEF	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. The induced filtration on MATH is the filtration defined by MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. If MATH and MATH exist (see proof), then <CASES> CASE: the limit MATH exists and is a bigraded object having MATH in bidegree MATH, CASE: the MATHth graded part MATH of the MATHth cohomology object of MATH is a subquotient of MATH. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH be a spectral sequence of bigraded objects of MATH with MATH of bidegree MATH. We say such a spectral sequence is <CASES> CASE: regular if for all MATH there is a MATH such that the maps MATH are zero for MATH, CASE: coregular if for all MATH there is a MATH such that the maps MATH are zero for MATH, CASE: bounded if for all MATH there are only a finite number of nonzero MATH, CASE: bounded below if for all MATH there is a MATH such that MATH for MATH. CASE: bounded above if for all MATH there is a MATH such that MATH for MATH. </CASES>  
LEM	  In the situation of Definition REF. Let MATH be the MATH-graded parts of MATH defined as in Section REF. <CASES> CASE: The spectral sequence is regular if and only if for all MATH there exists an MATH such that MATH CASE: The spectral sequence is coregular if and only if for all MATH there exists an MATH such that MATH CASE: The spectral sequence is bounded if and only if it is both bounded below and bounded above. CASE: If the spectral sequence is bounded below, then it is regular. CASE: If the spectral sequence is bounded above, then it is coregular. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. We say the spectral sequence associated to MATH <CASES> CASE: weakly converges to MATH if MATH via Lemma REF for all MATH, CASE: abuts to MATH if it weakly converges to MATH and MATH and MATH for all MATH, CASE: converges to MATH if it is regular, abuts to MATH, and MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. The associated spectral sequence <CASES> CASE: weakly converges to MATH if and only if for every MATH we have equality in equations (REF) and (REF), CASE: abuts to MATH if and only if it weakly converges to MATH and we have MATH and MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. Assume that the filtration on each MATH is finite (see Definition REF). Then <CASES> CASE: the spectral sequence associated to MATH is bounded, CASE: the filtration on each MATH is finite, CASE: the spectral sequence associated to MATH converges to MATH, CASE: if MATH is a weak Serre subcategory and for some MATH we have MATH for all MATH, then MATH is in MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. Assume that the filtration on each MATH is finite (see Definition REF) and that for some MATH we have only a finite number of nonzero MATH. Then only a finite number of MATH are nonzero and we have MATH in MATH where MATH is the smallest weak Serre subcategory of MATH containing the objects MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a filtered complex of MATH. Assume <CASES> CASE: for every MATH there exist MATH such that MATH for MATH, CASE: for every MATH there exist MATH such that MATH is an isomorphism for MATH. </CASES> Then <CASES> CASE: the spectral sequence associated to MATH is bounded, CASE: the filtration on each MATH is finite, CASE: the spectral sequence associated to MATH converges to MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a double complex. The spectral sequences associated to MATH have the following terms: <CASES> CASE: MATH with MATH, CASE: MATH with MATH, CASE: MATH with MATH, CASE: MATH with MATH, CASE: MATH, CASE: MATH. </CASES>  
DEF	  Let MATH be an abelian category. Let MATH be a double complex. We say the spectral sequence MATH weakly converges to MATH, abuts to MATH, or converges to MATH if Definition REF applies. Similarly we say the spectral sequence MATH weakly converges to MATH, abuts to MATH, or converges to MATH if Definition REF applies.  
LEM	  Let MATH be an abelian category. Let MATH be a double complex. Assume that for every MATH there are only finitely many nonzero MATH with MATH. Then <CASES> CASE: the two spectral sequences associated to MATH are bounded, CASE: the filtrations MATH, MATH on each MATH are finite, CASE: the spectral sequences MATH and MATH converge to MATH, CASE: if MATH is a weak Serre subcategory and for some MATH we have MATH for all MATH, then MATH is in MATH. Similarly for MATH. </CASES>  
LEM	  Let MATH be an abelian category. Let MATH be a complex. Let MATH be a double complex. Let MATH be morphisms. Assume that <CASES> CASE: For every MATH there are only finitely many nonzero MATH with MATH. CASE: We have MATH if MATH. CASE: The morphisms MATH give rise to a morphism of complexes MATH. CASE: The complex MATH is exact in all degrees MATH and the morphism MATH induces an isomorphism MATH. </CASES> Then MATH induces a quasi-isomorphism MATH of complexes. Moreover, there is a variant of this lemma involving the second variable MATH instead of MATH.  
LEM	  Let MATH be an abelian category. Let MATH be a complex of MATH. Let MATH be a homotopy equivalence in the category of complexes of complexes of MATH. Then the map MATH induced by MATH is a homotopy equivalence.  
LEM	  Let MATH be a complex of abelian groups. Let MATH be an exact complex of complexes of abelian groups. Set MATH to obtain a double complex. Then the map MATH induced by MATH is a quasi-isomorphism.  
LEM	  Let MATH be a complex of abelian groups. Let MATH be an exact complex of complexes of abelian groups such that for all MATH the complexes MATH are exact as well. Set MATH to obtain a double complex. Then MATH induced by MATH is a quasi-isomorphism.  
LEM	  Let MATH be a complex of abelian groups. Let MATH be an exact complex of complexes of abelian groups such that for all MATH the complexes MATH are exact as well. Set MATH to obtain a double complex. Let MATH be the product total complex associated to the double complex (see proof). Then the map MATH induced by MATH is a quasi-isomorphism.  
LEM	  Let MATH be a complex of abelian groups. Let MATH be an exact complex of complexes of abelian groups. Set MATH to obtain a double complex. Let MATH be the product total complex associated to the double complex (see proof). Then the map MATH induced by MATH is a quasi-isomorphism.  
DEF	  Let MATH be an abelian category. An object MATH is called injective if for every injection MATH and every morphism MATH there exists a morphism MATH making the following diagram commute MATH  
LEM	  Let MATH be an abelian category. Let MATH be an object of MATH. The following are equivalent: <CASES> CASE: The object MATH is injective. CASE: The functor MATH is exact. CASE: Any short exact sequence MATH in MATH is split. CASE: We have MATH for all MATH. </CASES>  
LEM	  Let MATH be an abelian category. Suppose MATH, MATH is a set of injective objects of MATH. If MATH exists then it is injective.  
DEF	  Let MATH be an abelian category. We say MATH has enough injectives if every object MATH has an injective morphism MATH into an injective object MATH.  
DEF	  Let MATH be an abelian category. We say that MATH has functorial injective embeddings if there exists a functor MATH such that <CASES> CASE: MATH, CASE: for any object MATH the morphism MATH is injective, and CASE: for any object MATH the object MATH is an injective object of MATH. </CASES> We will denote such a functor by MATH.  
DEF	  Let MATH be an abelian category. An object MATH is called projective if for every surjection MATH and every morphism MATH there exists a morphism MATH making the following diagram commute MATH  
LEM	  Let MATH be an abelian category. Let MATH be an object of MATH. The following are equivalent: <CASES> CASE: The object MATH is projective. CASE: The functor MATH is exact. CASE: Any short exact sequence MATH in MATH is split. CASE: We have MATH for all MATH. </CASES>  
LEM	  Let MATH be an abelian category. Suppose MATH, MATH is a set of projective objects of MATH. If MATH exists then it is projective.  
DEF	  Let MATH be an abelian category. We say MATH has enough projectives if every object MATH has an surjective morphism MATH from an projective object MATH onto it.  
DEF	  Let MATH be an abelian category. We say that MATH has functorial projective surjections if there exists a functor MATH such that <CASES> CASE: MATH, CASE: for any object MATH the morphism MATH is surjective, and CASE: for any object MATH the object MATH is an projective object of MATH. </CASES> We will denote such a functor by MATH.  
LEM	  [ A functor with an exact left adjoint preserves injectives ] Let MATH and MATH be abelian categories. Let MATH and MATH be additive functors with MATH right adjoint to MATH. Consider the following conditions: <CASES> CASE: MATH transforms injective maps into injective maps, CASE: MATH is exact, and CASE: MATH transforms injectives into injectives. </CASES> Then (a) MATH (b) MATH (c). If MATH has enough injectives, then all three conditions are equivalent.  
LEM	  Let MATH and MATH be abelian categories. Let MATH and MATH be additive functors. Assume <CASES> CASE: MATH is right adjoint to MATH, CASE: MATH transforms injective maps into injective maps, CASE: MATH has enough injectives, and CASE: MATH implies MATH for any MATH. </CASES> Then MATH has enough injectives.  
LEM	  Let MATH and MATH be abelian categories. Let MATH and MATH be additive functors. Assume <CASES> CASE: MATH is right adjoint to MATH, CASE: MATH transforms injective maps into injective maps, CASE: MATH has enough injectives, CASE: MATH implies MATH for any MATH, and CASE: MATH has functorial injective embeddings. </CASES> Then MATH has functorial injective embeddings.  
LEM	  Let MATH and MATH be abelian categories. Let MATH be a functor. If there exists a subset MATH such that <CASES> CASE: every object of MATH is a quotient of an element of MATH, and CASE: for every MATH there exists an object MATH of MATH such that MATH functorially in MATH, </CASES> then there exists a left adjoint MATH of MATH.  
LEM	  Let MATH be a category, let MATH be a pre-additive Karoubian category, and let MATH be a diagram. <CASES> CASE: Assume MATH is filtered. The following are equivalent <CASES> CASE: MATH is essentially constant, CASE: MATH exists and there exists a cofinal filtered subcategory MATH and for MATH a direct sum decomposition MATH such that MATH maps isomorphically to MATH and MATH to zero in MATH for some MATH in MATH. </CASES> CASE: Assume MATH is cofiltered. The following are equivalent <CASES> CASE: MATH is essentially constant, CASE: MATH exists and there exists an initial cofiltered subcategory MATH and for MATH a direct sum decomposition MATH such that MATH maps isomorphically to MATH and MATH is zero for some MATH in MATH. </CASES> </CASES>  
LEM	  Let MATH be a category. Let MATH be an additive, Karoubian category. Let MATH and MATH be functors. The following are equivalent <CASES> CASE: MATH exists, and CASE: MATH and MATH exist. </CASES> In this case MATH.  
LEM	  Let MATH be a filtered category. Let MATH be an additive, Karoubian category. Let MATH and MATH be functors. The following are equivalent <CASES> CASE: MATH is essentially constant, and CASE: MATH and MATH are essentially constant. </CASES>  
LEM	  Let MATH be a category. <CASES> CASE: If MATH is an additive category, then the category of inverse systems with values in MATH is an additive category. CASE: If MATH is an abelian category, then the category of inverse systems with values in MATH is an abelian category. A sequence MATH of inverse systems is exact if and only if each MATH is exact. </CASES>  
DEF	  Let MATH be an abelian category. We say the inverse system MATH satisfies the Mittag-Leffler condition, or for short is ML, if for every MATH there exists a MATH such that MATH for all MATH.  
LEM	  Let MATH be a short exact sequence of inverse systems of abelian groups. <CASES> CASE: In any case the sequence MATH is exact. CASE: If MATH is ML, then also MATH is ML. CASE: If MATH is ML, then MATH is exact. </CASES>  
LEM	  Let MATH be an exact sequence of inverse systems of abelian groups. If the system MATH is ML, then the sequence MATH is exact.  
LEM	  Let MATH be an abelian category. Let MATH be an inverse system in MATH with limit MATH. Then MATH is essentially constant (see Categories, Definition REF) if and only if there exists an MATH and for all MATH a direct sum decomposition MATH such that (a) the maps MATH are compatible with the direct sum decompositions, (b) for all MATH there exists some MATH such that MATH is zero.  
LEM	  Let MATH be an exact sequence of inverse systems of abelian groups. If MATH is essentially constant, then MATH has ML if and only if MATH has ML.  
LEM	  Let MATH be an inverse system of complexes of abelian groups and denote MATH its limit. Denote MATH, MATH the inverse systems of cohomologies, and denote MATH, MATH the cohomologies of MATH. If MATH and MATH are ML and MATH is essentially constant, then MATH.  
LEM	  Let MATH be an ordinal. Let MATH, MATH be an inverse system of complexes of abelian groups over MATH. If for all MATH the complex MATH is acyclic and the map MATH is surjective, then the complex MATH is acyclic.  
LEM	  Let MATH be a set. For MATH let MATH be a complex of abelian groups. Let MATH be the cohomology. Then MATH is a complex of abelian groups with homology MATH.  
